-- Postgres schema for Scheme A (Supabase)
-- Run this in Supabase SQL editor (adjust schema if needed)

-- Optional: dedicated enum for offering type
do $$ begin
  if not exists (select 1 from pg_type typ join pg_namespace nsp on nsp.oid = typ.typnamespace where typ.typname = 'course_type') then
    create type course_type as enum ('mandatory','optional');
  end if;
end $$;

-- Drop legacy course-level tag link table if it exists so tags can attach only to offerings
drop table if exists public.course_tags cascade;

create table if not exists public.courses (
  id bigint generated by default as identity primary key,
  course_name text not null,
  course_code text not null,
  course_url text,
  credits integer not null,
  lang text not null,
  semester text not null,
  exam_form text,
  workload text,
  constraint uniq_course_code unique (course_code)
);

create table if not exists public.course_offerings (
  id bigint generated by default as identity primary key,
  course_id bigint not null references public.courses(id) on delete cascade,
  row_id text not null,
  section text not null,
  type course_type not null,
  prof_name text,
  score_skills_sigmoid numeric(6,5),
  score_product_sigmoid numeric(6,5),
  score_venture_sigmoid numeric(6,5),
  score_foundations_sigmoid numeric(6,5),
  constraint uniq_course_section unique (course_id, section),
  constraint uniq_offering_row unique (row_id)
);

create index if not exists idx_offerings_course on public.course_offerings(course_id);
create index if not exists idx_offerings_section on public.course_offerings(section);
create index if not exists idx_offerings_type on public.course_offerings(type);

create table if not exists public.tag_types (
  id bigint generated by default as identity primary key,
  name text unique not null
);

insert into public.tag_types (name)
  values ('keywords'), ('available_programs')
on conflict (name) do nothing;

create table if not exists public.tags (
  id bigint generated by default as identity primary key,
  tag_type_id bigint not null references public.tag_types(id) on delete cascade,
  name text not null,
  constraint unique_tag unique (tag_type_id, name)
);

-- Tags attach to offerings (course-level tags are deprecated)
create table if not exists public.offering_tags (
  offering_id bigint not null references public.course_offerings(id) on delete cascade,
  tag_id bigint not null references public.tags(id) on delete cascade,
  primary key (offering_id, tag_id)
);

-- View consumed by the Cloudflare Pages Function
create or replace view public.courses_search_view as
select
  c.id,
  c.course_name,
  c.course_code,
  c.course_url as url,
  c.credits,
  c.lang,
  c.semester,
  c.exam_form,
  c.workload,
  agg.primary_prof_name as prof_name,
  agg.primary_type as type,
  agg.prof_names,
  agg.offering_types,
  agg.max_score_skills_sigmoid,
  agg.max_score_product_sigmoid,
  agg.max_score_venture_sigmoid,
  agg.max_score_foundations_sigmoid,
  coalesce(tags_kw.keywords, array[]::text[]) as keywords,
  coalesce(tags_ap.available_programs, array[]::text[]) as available_programs
from public.courses c
left join (
  select
    co.course_id,
    min(co.prof_name) as primary_prof_name,
    min(co.type) as primary_type,
    string_agg(distinct co.prof_name, ', ' order by co.prof_name) as prof_names,
    string_agg(distinct co.type::text, ', ' order by co.type::text) as offering_types,
    max(co.score_skills_sigmoid) as max_score_skills_sigmoid,
    max(co.score_product_sigmoid) as max_score_product_sigmoid,
    max(co.score_venture_sigmoid) as max_score_venture_sigmoid,
    max(co.score_foundations_sigmoid) as max_score_foundations_sigmoid
  from public.course_offerings co
  group by co.course_id
 ) agg on agg.course_id = c.id
left join (
  -- Aggregate keywords from offering-level tags up to course level
  select
    co.course_id,
    array_agg(distinct t.name) filter (where tt.name = 'keywords') as keywords
  from public.offering_tags ot
  join public.course_offerings co on co.id = ot.offering_id
  join public.tags t on t.id = ot.tag_id
  join public.tag_types tt on tt.id = t.tag_type_id
  group by co.course_id
) tags_kw on tags_kw.course_id = c.id
left join (
  -- Aggregate available_programs from offering-level tags up to course level
  select
    co.course_id,
    array_agg(distinct t.name) filter (where tt.name = 'available_programs') as available_programs
  from public.offering_tags ot
  join public.course_offerings co on co.id = ot.offering_id
  join public.tags t on t.id = ot.tag_id
  join public.tag_types tt on tt.id = t.tag_type_id
  group by co.course_id
) tags_ap on tags_ap.course_id = c.id;

-- Grant read on view to anon (keep base tables private)
do $$ begin
  perform 1 from pg_roles where rolname = 'anon';
  if found then
    grant usage on schema public to anon;
    grant select on public.courses_search_view to anon;
  end if;
end $$;
